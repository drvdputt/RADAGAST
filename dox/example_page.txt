/*! @page example_page Using the library

Once the build process described in @ref build_page is successful, take note of the install
directory and take a look at the header files in the generated include/ directory. Point your
compiler options / development environment / toolchain to the correct locations, and try one of
these examples.

@section example_sec Code examples

@note Some of the class names in these code snippets are clickable links to the class documentation.

@subsection setup_example_subsec Setup

The idea is that your code manages a single @c GasInterface object. When this object is
constructed, all of its members will be set up too, reading in all of the necessary data. While
it is safe for multiple of these objects to exist alongside each other, doing so should only be
done for experimentation purposes.

The arguments for the @c GasInterface constructor currently consist of three frequency grids.
They are called @c iFrequencyv, @c oFrequencyv, and @c eFrequencyv. They specify the frequency
grid for, respectively:

 - the input radiation field

 - the resulting opacity of the gas

 - the resulting emissivity of the gas

In the snippet below, we initialize the gas module using the same frequency grid for all three
of these physical quantities. What the contents of @c frequencyv are depends on the needs of the
user, but generally speaking, the frequency range just above the H ionization threshold should
be relatively well sampled.

In the future, some commonly used runtime options (mostly related to the physical level of
detail) might be passed here too, but for now most of the settings are baked in at compile time.

@code
#include "GasInterface.hpp"
#include <valarray>

// Set up frequency grid
std::valarray<double> frequencyv;
// < more code >

// Initialize the gas module by creating a GasInterface object.
GasModule::GasInterface gasInterface(frequencyv, frequencyv);

// Make some place to store a gas state per cell.
std::vector<GasModule::GasState> gasStatev(numCells);
@endcode

The last line of code allocates some space to store the solution for a single computational
element. This is optional: You can also just use a single, temporary gas state and extract what
you need before discarding it.

@subsection update_example_subsec Solve for equilibrium in a cell

The main goal of this code is to calculate the equilibrium temperature and abundances for a
given density, radiation field, and a local set of grain properties.

To pass the grain properties, we need to use another class that I haven't introduced yet: @c
GrainInterface. Your code should gather all the relevant grain properties (grain effective
radii, number densities and absorption efficiencies) into such an object. The default
constructor creates an empty object, representing a medium with zero dust present.

For every cell, the radiation and density are obtained from elsewhere in the code. Then, an
empty @c GrainInterface is created. This info is passed to the @c updateGasState function of @c
GrainInterface, along with a writable reference to a @c GasState object, to which the most
important output will be written. The pseudocode @c parallel_for_loop emphasizes that @c
updateGasState is thread safe.

@code
parallel_for_loop(0, numCells, [&] (int cell) {
  // Specific intensity in frequency units (erg s-1 cm-2 sr-1 Hz-1), and the number density of H nuclei in cm-3
  const std::valarray<double>& specificIntensityv = i_nuv(cell);
  double nH = hdensity(cell);

  // No grains
  const GasModule::GrainInterface grainInterface;

  // Solve for T
  gasInterface.updateGasState(gasStatev[cell], nH, Tguess, grainInterface);
}
@endcode

@subsection graininterface_example_subsec Dealing with grains

Essentially, @c GrainInterface is just a wrapper around a vector of @c
GrainInterface::Population objects. Populations can be added using @c
GrainInterface::addPopulation(). Each population represents a collection grains of the same
type, with a certain grain size distribution and absorption efficiency.

For every grain population, a flag specifying silicate or graphite needs to be provided. This
influences the grain photoelectric heating recipe, and determines some constants related to H2
formation on the surface of the grains. The absorption efficiency @f$ Q_\text{abs}(a, \nu) @f$
is used to calculate the grain temperatures* and the photoelectric efficiency. It needs to be
provided separately, independent from the carbon or silicate flag. It should be tabulated for
every grain size (first index) and for every frequency of the frequency grid used for the input
radiation field (@c iFrequencyv).

@note * While the grain temperatures need to be passed, the gas module actually recalculates the
grain temperatures by itself. This is because the gas and the grains exchange energy through
collisions and H2 formation. The given temperatures are only used for the initial guess.

@code
#include "GrainInterface.hpp"

// Create grain interface
GasModule::GrainInterface grainInterface;

for (pop = 0; pop < numPop; pop++) {
   // Choose one of two supported types
   GasModule::GrainTypeLabel type = GasModule::GrainTypeLabel::CAR;

   // Gather these physical quantities
   std::valarray<double> sizev = grain_sizes(pop);
   std::valarray<double> densityv = grain_number_density_per_size(pop);
   std::valarray<double> temperaturev = grain_temperature_per_size(pop);
   std::vector<std::valarray<double>> qAbsvv = qabs_nu_per_size(pop);
   std::valarray<double> = 

   // Use the interface to add the population
   grainInterface->addPopulation(type, sizev, densityv, temperaturev, iFrequencyv, qAbsvv);
}
@endcode

@note The example code above was written from the standpoint that the grains are completely
different for each individual cell of a simulation. In most simulations, this is not the case.
Often, a fixed grid of sizes is used throughout all the cells, and only the densities change.
The grain number densities of a population contained in an existing @c GrainInterface object can
be adjusted safely using @c GrainInterface::changePopulationDensityv(). This is more efficient
than making a new @c GrainInterface each time, since some precalculations (that do not depend on
the grain number densities) are performed every time addPopulation() is called.

@subsection retrieve_example_subsec Retrieving gas properties.

When @c updateGasState() has finished, @c GasState object will contain a minimal set of
properties describing the result of the equilibrium calculation (effectively, the temperature
and some densities). @c GasInterface provides several functions which can be used to derive
other properties from the stored quantities. Sometimes, some recalculations might be involved
(such as level populations), but since the equilibrium temperature and densities are already
known, no iterations are necessary and the overhead should be less than 10% of the update time.
A couple of examples:

@code
GasModule::GasState& gs = gasStatev[cell]
std::valarray<double> emv = gasInterface.emissivity(gs);
std::valarray<double> opv = gasInterface.opacity(gs);
int h_index = gasInterface.index("H")
int h2_index = gasInterface.index("H2")
std::cout << "H density is " << gs.density(h_index)
          << " and H2 density is " << gs.density(h2_index) << '\n';
@endcode

*/
