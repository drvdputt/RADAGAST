/*! \mainpage GasModule Index

\section build_sec Build instructions
\subsection debug_build_subsec Debug build

The Makefile that comes with the repo compiles the code in the parent directory of the repo. During
the compilation step, all the object files (*.o) will be placed in ../obj. Dependency files (*.d)
are also generated for each object file; for each *.o file, we let the compiler generate a *.d file
which described the dependency of the object itself on its inluded headers, as well as any recursive
dependencies for the headers.

These objects will then be linked into a binary called 'test', which is placed in ../bin. All the
objects are also placed in an archive at '../lib/libgasmodule.a', allowing it to be linked to other
codes.

Note that this debug build will ouput quite a number of debug messages. To build a version suitable
for inclusion in another code, see the instructions below.

\subsection include_build_subsec Include it 'manually'

The simplest way to use the gas module in your code, is to modify the Makefile a bit, build the code
separately, and then set the correct compiler flags in your project.

In the Makefile of the gas module, add the \c -DSILENT preprocessor option to disable all debug
messages. Add \c -O3 and remove \c -g for optimization. Not sure if this will work, but might be
useful: adjust the target directories.

To include the gas module in your code and link the result, use this include flag: \c
-I\<target_dir\>/include, where \c \<target_dir\> is the target directory you specified in the make
file. For the linking step, add the linker path \c -L\<target_dir\>/lib (this is where
libgasmodule.a will be put) and the linker flag \c -lgasmodule.

\subsection cmake_build_subsec Include in a CMake project

It is possible to add instructions to the CMakelists that create the gadmodule library as part of
the build process for the whole project. We use CMake to build SKIRT, so these instructions will be
based on the structure of SKIRT in terms of a CMake project.

In SKIRT, the source code of extra libraries such as cfitsio or voro is included as a subproject, in
sister directories of the core; so we have SKIRT/core/ SKIRT/fitsio and SKIRT/voro.
SKIRT/CMakeLists.txt lists all these subdirectories, with an add_subdirectory command for each of
them. Adding the gas module is straightforward: simply add a directory SKIRT/gasmodule, and put \c
add_subdirectory(gasmodule) in SKIRT/CMakeLists.txt.

In this subdirectory, make a new CMakeLists file, and there put something like this:

\code 
# ------------------------------------------------------------------
# Builds a library from the GasModule source
# ------------------------------------------------------------------

# set the target name
set(TARGET gasmodule)

# source files and their headers
file(GLOB SOURCES "/Users/drvdputt/GasModule/git/src/*.cpp")
file(GLOB HEADERS "/Users/drvdputt/GasModule/git/src/*.hpp")
# create the library target
add_library(${TARGET} STATIC ${SOURCES} ${HEADERS})

# Eigen dependencies
include_directories(SYSTEM /Users/drvdputt/GasModule/git/eigen3)

# GasModule header-only dependencies
include_directories(/Users/drvdputt/GasModule/git/include)

# adjust C++ compiler flags to our needs
include("../../SMILE/build/CompilerFlags.cmake")

# The SYSTEM flag for the eigen3 include will suppress the thousands of warnings thrown (in our
# case, because of compiler flags).
	
\endcode

If any of the subprojects make use of the gasmodule (SKIRT/core in our case), put the following in
their CMakeLists.txt:

\code
target_link_libraries(gasmodule)
include_directories(/Users/drvdputt/GasModule/git/src)
\endcode

\section example_sec Usage examples
\subsection setup_example_subsec Setup

\code
#include "GasInterface.h"

// Set up the gas module by creating a GasInterface object.
GasModule::GasInterface gasInterface(frequencyv);

// Make some place to store a gas state per cell.
std::vector<GasModule::GasState> gasStatev(numCells);
\endcode

\subsection update_example_subsec Update gas states

\code
// This is a regular for loop, but the code below should be thread safe, and hence safe for use in a
// parallel implementation of loops, if you have one.
for (int cell = 0; cell < numCells; cell++) {
  // Gather physical quantities in the cell (semi-pseudocode)

  // Get the specific intensity in frequency units (erg s-1 cm-2 sr-1 Hz-1), for the frequencies of
  // the grid (pseudocode).
  const std::valarray<double>& specificIntensityv = i_nuv(cell);

  // Get H density in cm-3, temperature guess.
  double nH = hdensity(cell);
  double Tguess = 8000;

  // Create grain interface object (see example below).
  const GasModule::GrainInterface& gi = makeGrainInterface(cell);

  // Call the update function.
  gasInterface.updateGasState(gasStatev[cell], nH, Tguess, gi);
}
\endcode

\subsection graininterface_example_subsec Creating a grain interface object

This is more complicated when using the custom grain model, as many quantities and functions that
depend on the grain model are required. Let's keep it to a simple example, using one of the built-in
grain types.

\code
#include "GrainInterface.h"

GasModule::GrainInterface makeGrainInterface(cell) {
  // First make a list of populations.
  std::vector<GasModule::GrainInterface::Population> populationv;
  populationv.reserve(numPop(cell));

  for (pop = 0; pop < numPop(cell); pop++) {
     // Gather the following properties for each population in the cell (semi-pseudocode)

     // Choose whether to use the carbonaceous or silicate built-in type
     GasModule::GrainTypeLabel type = GasModule::GrainTypeLabel::CAR;

     // Gather these physical quantities
     std::valarray<double>& sizev = sizes(pop);
     std::valarray<double>& densityv = number_densities_per_size(pop);
     std::valarray<double>& temperaturev = temperatures_per_size(pop);
     std::vector<std::valarray<double>>& qAbsvv = qabs_per_wavelength_per_size(pop);

     // Add a new population to the list
     populationv.emplace_back(type, sizev, densityv, temperaturev, qAbsvv);
  }
  // These populations will be stored in the new grain interface object
  return GasModule::GrainInterface(populationv);
}
\endcode

*/
