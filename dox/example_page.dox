/*! @page example_page Usage examples
@section example_sec Usage examples

Below are some examples of how to use the gas module. The way the different parts of the gas module
are used should be correct code (if nothing has changed meanwhile). The the other code around them
is fictional, which should make the context a bit clearer.

Some of the class names in these code names are clickable links to the class documentation. Most
functions, especially those of what I call the `public interface' are documented.

@subsection setup_example_subsec Setup

@code
#include "GasInterface.h"

// Set up the gas module by creating a GasInterface object.
GasModule::GasInterface gasInterface(frequencyv);

// Make some place to store a gas state per cell.
std::vector<GasModule::GasState> gasStatev(numCells);
@endcode

@subsection update_example_subsec Update gas states

@code
// This is a regular for loop, but the code below should be thread safe, and hence safe for use in a
// parallel implementation of loops, if you have one.
for (int cell = 0; cell < numCells; cell++) {
  // Gather physical quantities in the cell (semi-pseudocode)

  // Get the specific intensity in frequency units (erg s-1 cm-2 sr-1 Hz-1), for the frequencies of
  // the grid.
  const std::valarray<double>& specificIntensityv = i_nuv(cell);

  // Get H density in cm-3, temperature guess.
  double nH = hdensity(cell);
  double Tguess = 8000;

  // Create grain interface object (see example below).
  const GasModule::GrainInterface& gi = makeGrainInterface(cell);

  // Call the update function.
  gasInterface.updateGasState(gasStatev[cell], nH, Tguess, gi);
}
@endcode

@subsection graininterface_example_subsec Creating a grain interface object

This is more complicated when using the custom grain model, as many quantities and functions that
depend on the grain model are required. Let's keep it to a simple example, using one of the built-in
grain types.

@code
#include "GrainInterface.h"

GasModule::GrainInterface makeGrainInterface(cell) {
  // First make a list of populations. Use a unique pointer here, so the population vector can be
  // moved into the grain interface object
  auto populationv = std::make_unique<std::vector<GasModule::GrainInterface::Population>>();
  populationv->reserve(numPop(cell));

  for (pop = 0; pop < numPop(cell); pop++) {
     // Gather the following properties for each population in the cell (semi-pseudocode)

     // Choose whether to use the carbonaceous or silicate built-in type
     GasModule::GrainTypeLabel type = GasModule::GrainTypeLabel::CAR;

     // Gather these physical quantities
     std::valarray<double> sizev = sizes(pop);
     std::valarray<double> densityv = number_densities_per_size(pop);
     std::valarray<double> temperaturev = temperatures_per_size(pop);
     std::vector<std::valarray<double>> qAbsvv = qabs_per_wavelength_per_size(pop);

     // Add a new population to the list
     populationv->emplace_back(type, sizev, densityv, temperaturev, qAbsvv);
  }
  // These populations will be stored in the new grain interface object
  return GasModule::GrainInterface(std::move(populationv));
}
@endcode

@subsection retrieve_example_subsec Retrieving gas properties.

The gas properties are all stored in (or can be calculated from) the contents of the @c GasState
objects. Here a couple of examples for retrieving gas properties of a certain cell. Of course, all
of these will only work when the gas state object have been properly filled in, i.e. they have been
processed by @c updateGasStates().

@code
void print_some_properties_forexample(int cell, int freq) {
  // Choose a gas state (not a freshly created one! Valid contents are crucial here).
  GasModule::GasState& gs = gasStatev[cell]

  // There will be CGS variants in the future. But SKIRT likes them in SI.
  std::cout << "Emissivity: " << gasInterface.emissivity_SI(gs, freq) << " W m-2 sr-1 Hz-1\n";
  std::cout << "Opacity: " << gasInterface.opacity_SI(gs, freq) << " m-1" << std::endl;
}
@endcode

*/
